// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"
	"database/sql"

	"gorm.io/gorm"

	"gorm.io/gen"

	"gorm.io/plugin/dbresolver"
)

func Use(db *gorm.DB, opts ...gen.DOOption) *Query {
	return &Query{
		db:                db,
		CommandTemplate:   newCommandTemplate(db, opts...),
		Counter:           newCounter(db, opts...),
		HTTPSCommand:      newHTTPSCommand(db, opts...),
		HeaderTemplate:    newHeaderTemplate(db, opts...),
		MCondition:        newMCondition(db, opts...),
		Monitor:           newMonitor(db, opts...),
		MqttCommand:       newMqttCommand(db, opts...),
		ParserReturn:      newParserReturn(db, opts...),
		RedisCommand:      newRedisCommand(db, opts...),
		Schedule:          newSchedule(db, opts...),
		StageItem:         newStageItem(db, opts...),
		TaskTemplate:      newTaskTemplate(db, opts...),
		TaskTemplateStage: newTaskTemplateStage(db, opts...),
		TimeDatum:         newTimeDatum(db, opts...),
		TimeTemplate:      newTimeTemplate(db, opts...),
		WebsocketCommand:  newWebsocketCommand(db, opts...),
	}
}

type Query struct {
	db *gorm.DB

	CommandTemplate   commandTemplate
	Counter           counter
	HTTPSCommand      hTTPSCommand
	HeaderTemplate    headerTemplate
	MCondition        mCondition
	Monitor           monitor
	MqttCommand       mqttCommand
	ParserReturn      parserReturn
	RedisCommand      redisCommand
	Schedule          schedule
	StageItem         stageItem
	TaskTemplate      taskTemplate
	TaskTemplateStage taskTemplateStage
	TimeDatum         timeDatum
	TimeTemplate      timeTemplate
	WebsocketCommand  websocketCommand
}

func (q *Query) Available() bool { return q.db != nil }

func (q *Query) clone(db *gorm.DB) *Query {
	return &Query{
		db:                db,
		CommandTemplate:   q.CommandTemplate.clone(db),
		Counter:           q.Counter.clone(db),
		HTTPSCommand:      q.HTTPSCommand.clone(db),
		HeaderTemplate:    q.HeaderTemplate.clone(db),
		MCondition:        q.MCondition.clone(db),
		Monitor:           q.Monitor.clone(db),
		MqttCommand:       q.MqttCommand.clone(db),
		ParserReturn:      q.ParserReturn.clone(db),
		RedisCommand:      q.RedisCommand.clone(db),
		Schedule:          q.Schedule.clone(db),
		StageItem:         q.StageItem.clone(db),
		TaskTemplate:      q.TaskTemplate.clone(db),
		TaskTemplateStage: q.TaskTemplateStage.clone(db),
		TimeDatum:         q.TimeDatum.clone(db),
		TimeTemplate:      q.TimeTemplate.clone(db),
		WebsocketCommand:  q.WebsocketCommand.clone(db),
	}
}

func (q *Query) ReadDB() *Query {
	return q.ReplaceDB(q.db.Clauses(dbresolver.Read))
}

func (q *Query) WriteDB() *Query {
	return q.ReplaceDB(q.db.Clauses(dbresolver.Write))
}

func (q *Query) ReplaceDB(db *gorm.DB) *Query {
	return &Query{
		db:                db,
		CommandTemplate:   q.CommandTemplate.replaceDB(db),
		Counter:           q.Counter.replaceDB(db),
		HTTPSCommand:      q.HTTPSCommand.replaceDB(db),
		HeaderTemplate:    q.HeaderTemplate.replaceDB(db),
		MCondition:        q.MCondition.replaceDB(db),
		Monitor:           q.Monitor.replaceDB(db),
		MqttCommand:       q.MqttCommand.replaceDB(db),
		ParserReturn:      q.ParserReturn.replaceDB(db),
		RedisCommand:      q.RedisCommand.replaceDB(db),
		Schedule:          q.Schedule.replaceDB(db),
		StageItem:         q.StageItem.replaceDB(db),
		TaskTemplate:      q.TaskTemplate.replaceDB(db),
		TaskTemplateStage: q.TaskTemplateStage.replaceDB(db),
		TimeDatum:         q.TimeDatum.replaceDB(db),
		TimeTemplate:      q.TimeTemplate.replaceDB(db),
		WebsocketCommand:  q.WebsocketCommand.replaceDB(db),
	}
}

type queryCtx struct {
	CommandTemplate   *commandTemplateDo
	Counter           *counterDo
	HTTPSCommand      *hTTPSCommandDo
	HeaderTemplate    *headerTemplateDo
	MCondition        *mConditionDo
	Monitor           *monitorDo
	MqttCommand       *mqttCommandDo
	ParserReturn      *parserReturnDo
	RedisCommand      *redisCommandDo
	Schedule          *scheduleDo
	StageItem         *stageItemDo
	TaskTemplate      *taskTemplateDo
	TaskTemplateStage *taskTemplateStageDo
	TimeDatum         *timeDatumDo
	TimeTemplate      *timeTemplateDo
	WebsocketCommand  *websocketCommandDo
}

func (q *Query) WithContext(ctx context.Context) *queryCtx {
	return &queryCtx{
		CommandTemplate:   q.CommandTemplate.WithContext(ctx),
		Counter:           q.Counter.WithContext(ctx),
		HTTPSCommand:      q.HTTPSCommand.WithContext(ctx),
		HeaderTemplate:    q.HeaderTemplate.WithContext(ctx),
		MCondition:        q.MCondition.WithContext(ctx),
		Monitor:           q.Monitor.WithContext(ctx),
		MqttCommand:       q.MqttCommand.WithContext(ctx),
		ParserReturn:      q.ParserReturn.WithContext(ctx),
		RedisCommand:      q.RedisCommand.WithContext(ctx),
		Schedule:          q.Schedule.WithContext(ctx),
		StageItem:         q.StageItem.WithContext(ctx),
		TaskTemplate:      q.TaskTemplate.WithContext(ctx),
		TaskTemplateStage: q.TaskTemplateStage.WithContext(ctx),
		TimeDatum:         q.TimeDatum.WithContext(ctx),
		TimeTemplate:      q.TimeTemplate.WithContext(ctx),
		WebsocketCommand:  q.WebsocketCommand.WithContext(ctx),
	}
}

func (q *Query) Transaction(fc func(tx *Query) error, opts ...*sql.TxOptions) error {
	return q.db.Transaction(func(tx *gorm.DB) error { return fc(q.clone(tx)) }, opts...)
}

func (q *Query) Begin(opts ...*sql.TxOptions) *QueryTx {
	tx := q.db.Begin(opts...)
	return &QueryTx{Query: q.clone(tx), Error: tx.Error}
}

type QueryTx struct {
	*Query
	Error error
}

func (q *QueryTx) Commit() error {
	return q.db.Commit().Error
}

func (q *QueryTx) Rollback() error {
	return q.db.Rollback().Error
}

func (q *QueryTx) SavePoint(name string) error {
	return q.db.SavePoint(name).Error
}

func (q *QueryTx) RollbackTo(name string) error {
	return q.db.RollbackTo(name).Error
}
